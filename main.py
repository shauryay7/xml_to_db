import os
import argparse
import xml.etree.ElementTree as ET
from collections import defaultdict
from pymongo import MongoClient
from pprint import pprint


def parse_element(element, class_definitions):

    class_name = element.tag.capitalize()
    fields = defaultdict(str)

    for child in element:
        if len(child) > 0:
            fields[child.tag] = child.tag.capitalize()
            parse_element(child, class_definitions)
        else:
            fields[child.tag] = "String"

    class_definitions[class_name] = fields


def generate_java_class(class_name, fields):
    """Generate a Java class string from field definitions."""
    lines = [f"public class {class_name} {{"]

    for field_name, field_type in fields.items():
        lines.append(f"    private {field_type} {field_name};")
    lines.append("")

    for field_name, field_type in fields.items():
        capitalized = field_name[0].upper() + field_name[1:]
        lines.append(f"    public {field_type} get{capitalized}() {{ return {field_name}; }}")
        lines.append(f"    public void set{capitalized}({field_type} {field_name}) {{ this.{field_name} = {field_name}; }}")

    lines.append("}")
    return "\n".join(lines)


def generate_sql_table(class_name, fields):
    """Generate SQL table creation code from field definitions."""
    lines = [f"CREATE TABLE {class_name} ("]
    for field_name, field_type in fields.items():
        if field_type[0].isupper() and field_type != "String":
            lines.append(f"    {field_name}_id INT,")
        else:
            lines.append(f"    {field_name} VARCHAR(255),")
    lines[-1] = lines[-1].rstrip(',')
    lines.append(");")
    return "\n".join(lines)


def parse_entity(entity_elem):
    """Parses a single <Entity> element into a dictionary."""
    table_name = entity_elem.attrib.get("TableName") or entity_elem.attrib.get("name")
    entity_data = {"table_name": table_name}

    for child in entity_elem:
        tag = child.tag.lower()

        if tag == "attributes":
            attributes = []
            for attr in child.findall("Attribute"):
                attributes.append({k: v for k, v in attr.attrib.items()})
            entity_data["attributes"] = attributes

        elif tag == "indices":
            indices = []
            for index in child.findall("Index"):
                idx_data = {"name": index.attrib.get("Name")}
                idx_data["columns"] = [col.attrib.get("Name") for col in index.findall("Column")]
                indices.append(idx_data)
            entity_data["indices"] = indices

        elif tag == "exampledata":
            example = {}
            for field in child:
                example[field.tag] = field.text
            entity_data["example_data"] = example

    return entity_data


def insert_full_entity_data(xml_file, db_name="AutoGeneratedDB"):
    """Inserts parsed <Entity> data with attributes, indices, and example into MongoDB."""
    client = MongoClient("mongodb://localhost:27017/")
    db = client[db_name]
    collection = db["schema_definitions"]

    tree = ET.parse(xml_file)
    root = tree.getroot()

    inserted_count = 0
    for entity in root.findall(".//Entity"):
        entity_doc = parse_entity(entity)
        table_name = entity_doc.get("table_name")

        if table_name:
            # Upsert to avoid duplicates
            result = collection.update_one(
                {"table_name": table_name},
                {"$set": entity_doc},
                upsert=True
            )
            print(f"\n‚úÖ MongoDB: Inserted/Updated schema for `{table_name}`")
            print("üìù Inserted Document:")
            pprint(entity_doc)
            inserted_count += 1

    print(f"\n‚úÖ Done: {inserted_count} entity schemas inserted into `{db_name}.schema_definitions`")


def process_xml(xml_file, output_dir="output_classes", sql_file="output.sql", insert_mongo=False):
    """Main processing function: generates Java, SQL, and optionally inserts into MongoDB."""
    os.makedirs(output_dir, exist_ok=True)

    tree = ET.parse(xml_file)
    root = tree.getroot()

    class_definitions = {}
    parse_element(root, class_definitions)

    sql_statements = []
    for class_name, fields in class_definitions.items():
        java_code = generate_java_class(class_name, fields)
        java_path = os.path.join(output_dir, f"{class_name}.java")
        with open(java_path, "w") as java_file:
            java_file.write(java_code)
        print(f"‚úÖ Java: {class_name}.java written")

        sql_statements.append(generate_sql_table(class_name, fields))

    with open(sql_file, "w") as sql_out:
        sql_out.write("\n\n".join(sql_statements))
    print(f"‚úÖ SQL schema: {sql_file} written")

    if insert_mongo:
        insert_full_entity_data(xml_file)


def main():
    parser = argparse.ArgumentParser(description="Convert XML to Java classes, SQL schema, and insert into MongoDB.")
    parser.add_argument("xml_file", help="Path to the input XML file")
    parser.add_argument("--output", default="output_classes", help="Output directory for Java files")
    parser.add_argument("--sql", default="output.sql", help="Output file for SQL schema")
    parser.add_argument("--mongo", action="store_true", help="Insert data and schema into MongoDB")

    args = parser.parse_args()
    process_xml(args.xml_file, args.output, args.sql, insert_mongo=args.mongo)


if __name__ == "__main__":
    main()
